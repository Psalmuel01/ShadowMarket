{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"17420345720080259997","abi":{"parameters":[{"name":"user_secret","type":{"kind":"field"},"visibility":"private"},{"name":"position_side","type":{"kind":"integer","sign":"unsigned","width":1},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"blinding_factor","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"public"},{"name":"leaf_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"old_merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"new_merkle_root","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use std::hash::pedersen_hash;\n\nglobal TREE_DEPTH: u32 = 20;\n\nfn hash_pair(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right])\n}\n\nfn commitment_hash(\n    user_secret: Field, market_id: Field, position_side: u1, amount: u64, blinding_factor: Field,\n) -> Field {\n    // Matches Cairo `merkle_tree_lib::commitment_hash`.\n    let ab = hash_pair(user_secret, market_id);\n    let cd = hash_pair(position_side as Field, amount as Field);\n    let e0 = hash_pair(blinding_factor, 0);\n    hash_pair(hash_pair(ab, cd), e0)\n}\n\n// Public input schema (order is strict and bound in Market.cairo):\n// 0: market_id\n// 1: leaf_index\n// 2: commitment\n// 3: old_merkle_root\n// 4: new_merkle_root\nfn main(\n    user_secret: Field,\n    position_side: u1,\n    amount: u64,\n    blinding_factor: Field,\n    merkle_siblings: [Field; TREE_DEPTH],\n    market_id: pub Field,\n    leaf_index: pub u32,\n    commitment: pub Field,\n    old_merkle_root: pub Field,\n    new_merkle_root: pub Field,\n) {\n    assert(amount > 0);\n\n    let computed_commitment = commitment_hash(\n        user_secret,\n        market_id,\n        position_side,\n        amount,\n        blinding_factor,\n    );\n    assert(computed_commitment == commitment);\n\n    // Prove old root corresponds to an empty leaf at `leaf_index`,\n    // and new root corresponds to inserting `commitment` at the same index.\n    let mut old_node = 0;\n    let mut new_node = computed_commitment;\n    for level in 0..TREE_DEPTH {\n        let bit: u1 = ((leaf_index >> level) & 1) as u1;\n        let sibling = merkle_siblings[level];\n\n        if bit == 0 {\n            old_node = hash_pair(old_node, sibling);\n            new_node = hash_pair(new_node, sibling);\n        } else {\n            old_node = hash_pair(sibling, old_node);\n            new_node = hash_pair(sibling, new_node);\n        }\n    }\n\n    assert(old_node == old_merkle_root);\n    assert(new_node == new_merkle_root);\n}\n","path":"/Users/sam/Desktop/Starknet/ShadowMarket/circuits/position_commitment/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}