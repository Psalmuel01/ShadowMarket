{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"11844825574100822049","abi":{"parameters":[{"name":"user_secret","type":{"kind":"field"},"visibility":"private"},{"name":"position_side","type":{"kind":"integer","sign":"unsigned","width":1},"visibility":"private"},{"name":"amount","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"blinding_factor","type":{"kind":"field"},"visibility":"private"},{"name":"leaf_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"merkle_siblings","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"market_id","type":{"kind":"field"},"visibility":"public"},{"name":"market_root","type":{"kind":"field"},"visibility":"public"},{"name":"market_outcome","type":{"kind":"integer","sign":"unsigned","width":1},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"payout_low","type":{"kind":"field"},"visibility":"public"},{"name":"payout_high","type":{"kind":"field"},"visibility":"public"},{"name":"_payout_recipient","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZ3RzuS2kYXfZa59wXNYZJF+lcUicBJvYGBgB46zwCLIu69IqQ6zwf5quvXPzeh4xl2SSl1HrOqv1f/48ucf//j3v/zhp5//65e/ffn+P/7x5Y+//vT1609/+cPXX/70w28//fLz8bf/+JLGH6hfvud3X+Dnpn35Ph+b/uV7++4Lj//D/nn8Z/yP5fwn/+fxlxHqD7/9+uOP43/4l9jHHv/6w68//vzbl+9//vvXr999+e8fvv59/k9/++sPP8/tbz/8evxr+u7Ljz//+dgeAf/rp68/DvXP79ar08cvbbTrxc2aXg7/P6/Hx6+vtV6vr17eeL2nfL3ekd56PeP1/HD/N+ffUa7Xd+Kd15cWr/f+0evrx68HksUZHLr+yzm03WMAukIwUREKtiMQVRHM34rgOobc20cRcBPCclwKqx8HuHkvUO8F5vRhAN4EYGuKwLouRf+/IfJNiFVQbAUfhrCbPFA1YbT6VohM5TLX/F4I9Och8DSEFZ2ItfdyUbrSWdk/CsF0d1Etr4v6oU3y7r1ZV4haPnQq3rw70UuEQPf0ToijQlQiyT4+ipt0Fo+DqP9q2O13HENVkaX+oeeyfstjQIs3N4/jeSuVaPl5iPQ0xCox5vLheyLfvDMPu44SgyG/FcKyKYR9Qgh/L0SBQtT6ZoikEA2PT+TNECXpRArS4xD5zRC2QlT7KISlh3V6fwwqMtSPK8T41CtundvlFfVjvzJ77Nx3ITad25665v0xbDm3tW95DHvO/SJEfh4iPQ2x59wlP3bu2xB7zr0fwt8LseXcL0LsOPf2ibwZYs+5t0PkN0NsOXd96pr3x7Dl3NW+pXN78Sgx7x+mstbHJXYbYq/E9kP4eyG2SuxFiJ0S2z6RN0Psldh2iPxmiK0S8/Lw7X1/DFsl5v7wGG7HHT3pdtzR35mYZKR4Wx23xPxeCF2NY2rhT0MwpQ9D3M2vNGcoKO8MwArCrkrmWxM0vSFKzh8FaOXhBK3VxxO05o8naK09nqDdhtiboN2H2JqgvQiBpyH2Jmi3IfYmaN0eT9B6eTxB6/VxH3YXYrMP6097oPtj2OrDpq9+u4PYa8RehMjPQ6SnIfYaMaTyeJl4H2Nvnfg7YvibMbZWiq9i7CwV98/l3Rh7i8X9GPndGFvLReBpO/TiKLYWjMDTIdK9jW+N04D22MdvY2waOfjURF8cxZ6Vk9/0KPa8/FWM/Akx0uMYm3ZOf27ntzE27Xw/hr8ZY8/OX8TYsvPtc3k3xqadb8fI78bYs/P81EhfHMWenef2Le18b8aGu4+JdsvtNsZmue3H8Ddj7JXbixhb5bZ9Lu/G2Cy37Rj53Rh75Wb9abndH8VeuRU8PIrb4cjevO0uxOawbDfEm8OyYrHuKf4hb3Zc7YezKhR/PKxCaY+nVSj98bjqPsYm8XUfYw/5ehEDj2NsQl+3MfZmVqjl8dAKd0P6zakVqj9vd+5i7LY79bGH3h/FXrvj+KZHsdnuvIiRPyFGehxjs93x5x9y3sfYXH/58485X8TYW3/58w8698/l3Rib6y9//lnnixh766/29NPOF0ext/5qjz/vvPfzvfFV68/9/C7Grp/3x056fxR7ft7zNz2KTT9/ESN/Qoz0OMamn999wLTr57cxNv18P4a/GWPPz1/E2PLz7XN5N8amn2/HyO/G2PJzpsdOen8UW37O1L+pn+/Nr4jnBP19jL16+x0x/M0YW/X2KsZOve2fy7sx9uptP0Z+N8ZevT3+qOnFUezV2/OPmu7mJbuo1m6Md8dP/f87kX8bHpFPx0/k8/HT8b89Hj+Rz8dP9zH2xk8vYmyNn17FwOMYe+On+xibXzrMz8dPzM/HT8zPx0+3MXa/eJif3uxfHMXeVw8N3/QoNr98mJ+Pn17FSI9j7LUrtOfjp/sYm8snez5+ehFjb/lkz8dP++fybozN5ZM9Hz+9iLG3fCpPx08vjmJv+VT8sXc8Hz+xPB8/3cbY9fP62EnL8/ETa/6mR7Hp5+X5+OlVjPQ4xqaf1+fjp/sYm35en4+fXsTY8/P6fPy0fy7vxtj08/p8/PQixp6fP/7i0ouj2PNz79/UzzfHT+0Txk/tE8ZP7RPGT+0Txk/tE8ZP7RPGT+0Txk/tE8ZP7RPGT/3x+Kl9wvipP36Ww+28ZI+fuo2xOcLajvHuCKutZHz4dUN2fzrCupvh746wen88wsp332baHGHdx9gbYb2IsTXCehUDj2PsjbDuY+yNsHKqj0dY+e6Tps0RVk7PvzByG2Oz5cl4/ECc9PwLIxn8pkex1/K8ipE/IUZ6HGP3EVrPvzByH2P3IVrPvzDyIsbmY7Sef2Fk/1zejbH7JK3nXxh5EWNrCZYfP/TuxVFsLcEy22Pv8McjrJzTcz+/i7Hr5/mxk94fxZ6fZ/umR7Hp5y9i5E+IkR7H2PTzu4+adv38Nsamn+/H8Ddj7Pn5ixhbfr59Lu/G2PTz7Rj53Rh7fv74UXgvjmLPz0v6pn6+N8LKhc/r7TbGZr3tx/A3Y+zV24sYW/W2fS7vxtist+0Y+d0Ye/X2+OOmF0exV2/PP266nZdsjrDuYuyOsHZj3Iywtr/XWT+aQN1HUJ0cmX0rQndd03/J5u+IUPN6VxjeilBXhPbhtyGz8+EsL3t+PMvLbs9neXfPxdud5d3G2Jzl3cfYm+W9iIHHMTZnebcxNmd5dwP83Vle4/NZXsvPe7+7GLu93+NvNL04ir3e7/E3mu6PYrP3exEjf0KM9DjGZu/XP2Et2j9hLdo/YS3aP2Et2j9hLdo/YS3aP2Et2j9hLdqfr0UtPV6L9udrUUv5sXfw8SzPbp9Ktvlw/FQe+7k9/kbTi6PYez7+42803R/F5hPyX8TInxAjPY6x5+d299y8TT+/j7Hn578jhr8ZY8vPX8XY8fP9c3k3xp6f78fI78bY83M+ddIXR7H5Syflm/r53izPPuHhefYJD8+zT3h4nn3Cw/PsEx6eZ5/w8Dz7hIfn2Sc8PM8+4eF59vjhefYJD8+zxw/Pu5+X7M3ybmNszvK2Y7w5y3NNXOD24RzNLD+cYdntj+rszbCOkcrja3IbY/OabMd4e77KVWn4OKPl8UTPynM67z7G3kTvRYytid6rGHgcY2+idx9jb6Jn5TmdZ+U5nWflOZ13G2P799Gefhb64ij2OsDHP710fxSbHWB5Tue9ipEex9jsAOsnrEjrJ6xI6yesSOsnrEjrJ6xI6yesSOsnrEjrJ6xI6yesSP3xirR+worUH/+8YnlO51l7Tufdxtj18/bYSdtzOs+afdOj2PTz9pzOexUjPY6x6eftOZ13H2PTz9tzOu9FjD0/b8/pvP1zeTfGpp+353Teixh7fv74R5peHMWWn5eUvqmf7030Snr+ieh9jM0fmk3PPxF9EWPvp2bT809E98/l3Ribvzabnn8i+iLGVr0VPP1E9MVR7NUbns7xb6dg3jQF6x+SXHcRmul90by8E6Fn//9WX/8WoeDpN0MLnn8ztOD5N0MLn89abvO5Vk4J9sYVIagIyPm9CLogsPcijEnQFaG9wzlyTfHIfyMl//P4rx/+9NOvf/j6y59++O2nX37+23ihffn+eA+U+Wf98v1xpX3+2eafff6JNCr32GK84Y8tR8aPbb62dm3LeCMd2yPQmATCxw3t2LaBpx/bPsak331hurYYH7gdW17bPAZ2x9aubRk3zmNbR0t1bH0sCI5tG2+oY9vHb1R89yWna3vEG5Rm5rU94o3fDsh2bY94o7vL9doe8Ua/mNu1PeINb7B0bXGet/E8b7vO167ztXJt63ne5ud5WzvP2/p53uU634Jre51vydf2Ot9Srm09z7v4ed6lnedd+nne9Trfimt7nW/N1/Y631qu7XW+1a/tdb61n1u/ztdxbY94gzL0I95YPfkRb3AufsQbE02v19av7XizHHF9vF3Ge2e8X8Ytq40EpuMI28jg+BJyyyFGDkdyWwlRhzjCNA/RhhgBj8AYvyLeR+SR6j4ij2/i9RF5fBmu5xAj8rDXXkLUuT46hIdoc5l0iH4JpPkmH+/SBKkRfGQcKUvZmRSkcmblOJ0zDUgeooXoZ2YwSmikBrOGRm4wq2gkB4ikYFbSqSItQJWKxABNql85AtOVJBBXlkBeaQIjPRjVdalIEFilIkUYVXYpJWlU2qWUpEwpJWlU3KXKXHsMVedNf6ixj/FGxag81PmvPdSovkuNfYzmHrMCfbx21uCArDGrcAC1mHU4nkSDUYmXGvsYv4KMUY2XGvsYtzyMirzU2Md4qgbKdLURucw6H0dQZqWPeGXW+jS5KjXqPc0oTaoP8x7xRpVeCvPuMBSl8rTooUxq+OdpoFVq7GPcYjGqltNGR91yAO0YlcuxSMWo3UtRauxjfDiKUcEcGD5GDXN85IRRxbRp02Mfw2gwKvlSYx/jdoRRzZca+xiDYIx6vtTYx7yqo6I5huYYJc15BUdNs85bgM9h1VBNauxjGA5GXV9q7KPNmwWl8lxnDGVSZX70N1SVGvuYdTfq+1L9yhpTurLGFLliolSWsitrTOXKGlO9ssbkV9aYIlccVX4qRK4ISEWuOOr8UnZljfOeWefNsF5Z47xv1hkvcsVR56di5Iqjzi8VuSKzVOSKo84vFbkiXSpyxVHnpxp1ztFQctR5TvPmzKHG8Y06z2n+q0kVqTrUONJR53OUxFHnGTPyuCeOHy/lqPM8bqscdX6psY9x6+So80uNfYznuHLU+aXGPvKIPOo8z6s66jyPZ7Vy3nfnFZx33nkF5733VGMfcxkx6vxSYx+j6eSo80uNfZS5DHGpsY95tUadn2rUeZ7XbdT5pRhZqzmyVpWrqlzVKuWRtdoia7VH1jxF1ly5GnV+KeXKTUq5GnV+KY+seYuseY+sjTo/s9aUq0Yp5WrU+aWUq1allKtR55dSrnqSUq5GnV9q7GM8CJ6jzvNwfo46v1SVcqmxD5+vGPsYY/E86jyPCsijzi9FqbGPNheNYx/jvpBHnedxN8ijzvOoijzqPI9ayKPOL9UHCsmx0ExSYw2b5uKTUmNdN+7iedS5jftCHnVu426QR53buKp51LmNO3sedX6pPj+AH4vYJDX2Me7iea6UTzX2Me7iea6WTzXXj2NhO1fMpxr7GHfxPOr8Uv3KWh51fmYtK1dZuZp1fiqLrM06n1mbdT6zNut8Zi0rV7POpzLlyiClXFmWssjaqPMza1Yja+aRNVOuRp2fqihXBVLK1Vxnn0q5mmvtUylXc719KuVq1PmpRp3bWPvkUedms5HghWbkUeeXGvuw+YoiVaVcql3v4jzrfKpZ56eCFONqzTqfV2vW+amKVI2rNev8VE2qxxWcdT6v4KzzeQVnnc8rOOt8XrdZ56cqcd1GnV/K47qNOr9UjyvYU1zBjriCnXEFe47rNur8UiWu26jzS3lct1Hnl+rXdbOUpHBdNxt1fql8XTdLJlWuTNqsc59/F7my1KR6KKQrawZcWTPwypohX1kzRK5s1PmlIlc26/xUkSubdT7VrPORNZt1PrJmZ0c8jmDW+ciaMXJls85PFbmyWeenilwZe6isXGVIKVc5SylXuUjV631vs84HomajzueQ1kad21jf26zzU0Fq7GMMd2zW+alMavb3s6Ee+xhfDLZZ56M3sFnn425gs85HLdis81ONfYyVvs06P9XYx7yqs85PNfYxmlmbdT7GRDbrfHxtzGadz2s563z0ATbr/FRjH302+JTKY8Q54o06v1QZakQedX4pH1OXcc1HnV9q9O8DMLZR55cKLzEPLzHPUuEl5kWqSrlUeIl5eIm1JAWp8BJr4SXWTKpIhZdYU3001UcLL7EeXmI9vMR6eIn18BLrqo8eXmJd9dHDS6yrPnp4SUnhJSWFl5QUXlJSeElJJhVeUlKVCi8pqUmFlxQkqfCSAkqFlxSYVHhJQXhJQeSqoEmFlxSGlxSGlxSGlxSGlxRGrgqLVOSq0KUiV4XhJSWHl5QcXlJyeEnJ4SUlK1e5SClX2aWUqxxeUky5MkgpV5allCsrUuElxcJLioWXFAsvKSVJQSq8pJQsZVLhJaWEl5QSXlJKeEkp4SWlJqnwklIpFV5SqkmFl5QaXlJqeEmp4SWlhpcUT1LhJcUpFV5S3KTCS4pXqfCS4k0qvKS0JBVeUlp4SWlZKryktCJVpVwqvKS08JLSkxSkwktKDy8p3aSKVHhJ6aqPrvro4SU1hZfUFF5SU3hJTeElNZlUeElNVSq8pKYmFV5SEV5SEV5SEV5SEV5SYVLhJRVVKrykokmFl1QmqfCSSkqFl1SaVHhJZXhJZeSqskmFl9QcXlJzeEnN4SU1h5fUrFzlIqVcZZdSrnJ4SbXwkmrhJdXCS6qFl1RTrqxIKVfmUsqVhZfUolwVSClXJUspV6VIhZfUEl5SS3hJLeEltSYpSIWX1JqlTCq8pNbwklrDS2oNL6k1vKR6kgovqU6p8JLqJhVeUj28pHp4SfXwkurhJbUlqfCS2igVXlKbSYWX1Falwktqa1LhJbUnqfCS2sNLas9S4SW1F6kq5VLhJbWHl3hKUpAKL/EUXuLJpIpUeIlr3e5at3sKL3GElzjCSxzhJY7wEte63RFe4lq3O8JLXOt2R3iJM7zEGV7iDC9xhpe41u3O8BLXut0ZXuJatzvDS1zrds/hJa51u+fwEte63XN4iefwEs/KVVaucniJW3iJW3iJW3iJW3iJm3JlRUq5MpdSriy8xEt4iZfwEi/hJV7CS7woV6VIKVfFpZSrEl7iVbmqkFKuapZSrmqRCi/xGl7iNbzEa3iJe5KCVHiJe5YyqfAS9/AS9/AS9/AS9/ASb0kqvMQbpcJLvJlUeIm38BJv4SXewku8hZd4T1LhJd4pFV7i3aTCS7xXqfAS700qvKSlJBVe0lJ4SUtZKrykpSJVpVwqvKSl8JKGJAWp8JKG8JIGkypS4SVN6/amdXtDeEljeEljeEljeEljeEnTur0xvKRp3d4YXtK0bm8ML2k5vKTl8JKWw0taDi9pWre3HF7StG5vObykad3ecnhJ07q9WXhJ07q9WXhJ07q9WXhJs/CSZsqVKVcWXtJKeEkr4SWthJe0El7SinJVipRyVVxKuSrhJa2Gl7QaXtJqeEmr4SWtKle1SClX1aWUqxpe0ly5ckgpV56llCsvUuElzcNLmoeXNA8vaS1JQSq8pLUsZVLhJa2Fl7QWXtJaeElr4SWtJ6nwktYpFV7SukmFl7QeXtJ6eEnr4SWth5f0lKTCS3qiVHhJTyYVXtJTlQov6alJhZd0JKnwko7wko4sFV7SUaSqlEuFl3SEl3QmKUiFl3SGl3SaVJEKL+lat3et2zvDS3oOL+k5vKTn8JKew0u61u09h5d0rdt7Di/pWrf3HF7SLbykW3hJt/CSbuElXev2buElXev2buElXev2buElXev2XsJLutbtvYSXdK3bewkv6SW8pBflqihXJbyk1/CSXsNLeg0v6TW8pFflqhYp5aq6lHJVw0u6h5d0Dy/pHl7SPbyku3LlRUq5cpdSrjy8pDflqkFKuWpZSrlqRSq8pLfwkt7CS3oLL+k9SUEqvKT3LGVS4SW9h5f0Hl7Se3hJ7+ElSCktGW5ySC4ZfnJIWzIc5ZBhKYcMTzlkmMohw1WQkJYMXzkklwxnOaQtGd5yyLpkuMsh25LhL0hMS4bDHDIs5pB5yTCZQ5Yl65K+ZBjNIbtkTktiyTCbQ4bbHNKWLEuG4RzSl2xLhucgWZjOIcN1Dhm2c8jwnUPakuE8h6xLhvccsi0Z7oNUwn4OGf5zyDCgQ4YDHdKWDA86ZF0yXOiQbcnwISQt+g8ZTnRILhledEhbsijVtSqpdWWyrkzWLulJSXUoqU4l1bOS6iuTXpZcmXRfcmXSu2RLSmqDktqopLaspLaVyVaWXJlsvuTKZOuSfWWyY8mVyZ6XXJnsZckwq0OGWx0y7OqQ4VeYtF1ILBmWhQnchbQlw7UwqbtpW5jc3fQtTPJuGhcme3fa1aTvQsq5JoAXUs41EbyQcq4J4Z3ONSm807kmhnc61+TwTruaIF5IOddE8ULKuSaMF1LONXG8kHKuCeSFlHNNJC+knGtCeaddTSovpJxrcnkh65K+pJxrsnmXtLQklpRzTT7vLKcJ6IUsS8q5oF4CUDMBmJwLRc6FIueaoN5ZZChyLqilwGT1zsqCmgqgyLmgtgIoci5UOdck9s4iQ5Vzocq5oOYCk9o7KwtqL4Aq54IaDKDKuaAWA5PdOysLajIAl3NBbQbgcq4J8F1J9ZVJX5l0OReanAtNzjUxviupTc6FtjLZypIrk82XXJlsci50Odfk+a6kdjkXupwLfWWylyVXJrsvuTLZ5VwUCIBJ9oVUJpnyksrkpPtCyrkm33c61wT8TueahN/pURPxC4kl5VyT8gtpS8q5Juh3Otck/U7nmqjf6VyT9TvtasJ+IeVcE/cLKeeawF9IOddE/k7nmszf6VwT+juda1J/p11N7C+knGuCfyHlXBP9CynnmvBfSDnXxP9CyrkmABhSzjURwNOuJgMYUs41KcCQdUlfUs51koCnLGlJLCnnOmnAM33FlixLyrmozgVU64KTCZxFdkKBs8hOKvBMdZVznVzgrCyqgcEkA8/KoloYsMq5qCYGrHIuupxr8oFnkdHlXHQ5F9XKYDKCZ2VRzQzoci6qnQFdzsW26q3JudhWvTU5F9uqtybnOnHBM6ltZbKtTDY514kMnkntcq4TGjyT2uVc7CuTvSy5Mtl9yZXJLufKSc416cEzqTnJuXKSc2UBB5gEYUhlMidfUpk8KcJTCjvAyRFeUpk8ScJLKpMnS3hJOdekCU/nOnHCcv6tnOsECi+JJeVcJ1N4SVtSznVihdO5Tq7wZPgp55pk4WlXEy0MKeeacGFIOdfEC0PKuSZgeDrXJAxP55qI4elckzE87eqEDC8p5zoxw0vKuSZoGFLONVHDkHKuCRuGlHNN3DCknOsEDqddncThJeVcJ3N4ybqkLynnykXOlWtaEkvKuSZ7eJbThA9DliXlXHn1OHn1OCeBOIvsRBBnkZ0M4plql3OdFOKsrLx6nMkhnpWVV4+TXc6VV4+TXc6Vm5xr0ohXkTU5V25yrrx6nJNIPCtr9Tgnk3hW1upxTirxrKzV45xc4llZq8c5ycSzslaPk7uca8KJV1L7ymRfmexyLktyLktyLktyLktyLhPUgJNSvKQyacmXVCYtybkMci6DnMsg5zLIuUx4AwxlSWXyJBYvqUyezOIpBTngpBYvqUye3OIllcmTXLyknGuyi6dznfBiOf9WznXii5fEknKuk2C8pC0p5zohxulck2I8nevEGKdznRzj+V0jS0vKuU6U8ZJyrhNmvKSc68QZp3OdPON0rhNoPK+8yblOpPGScq4TaryknGtijSHlXBNsDCnnmmhjSDnXhBtDyrlMGDNMHDNMIDNMJDNMKDNMLDNMMDNMNDNMODNMPDNMQDNMRDNMSDNMTDNMUDNs9Ti2ehwT1wwT2AwT2QwT2gwT2wxbPY6JboatHsfEN8NWj2MinGFCnGFinGGCnGGinGGrxzFxzrDV45hIZ9jqcUysM8rqcYpoZ5TV4xTxziirxykinlGEPKOInUARPIEi6hlF2DOKuGcUgc8oIp9RhFCgiH1GEUSBIvoZRRgFivhnFAHQKCKgUYRAo4iBRhFMgSIKGkU4BYo4aBQBFSgioVHyyqRYaJS8MikaGiWvTIqHRhEQjSIiGkVINIqYaBRB0SiiolGERaOIi0YRGI0iMhpFaDSK2GgUwdEooqNRhEejiI9GESCNIkIaRYg0ihhpFEHSKKKkUYRJo4iTRhEojSJSGkWoNIpYaRTB0iiipVGES6OIl0YRMI0iYhpFyDSKmGkUQdMooqZRhE2jiJtGETiNInIaReg0ithpFMHTKKKnUYRPo4ifRhFAjSKCGkUINcrqccrqcYooahRh1CjiqFEEUqOIpEZZPU4RS42yepwimhpl9ThFPDWqgGpUEdWoQqpRxVSjrh6niqpGXT1OFVeNunqcKrIadfU4VWw16upxquhq1NXjVPHVqAKsUUVqoArVQBVjjSrIGlWUNaowa1Rx1qgCNlBFWqMK2UAVa40qaANVtDWqcGtU8daoAq5RRVyj5pVJMdeoeWVS1DVqXpkUd41qK5Mir1FtZVLsNaqtTIq+RhV+jSr+GlUANqoIbFQh2KhisFEFYaOKwkYVho0qDhtVIDaqSGxUodioYrFRBWOjisZGFY6NKh4bVUA2qohsVCHZqGKyUQVlo4rKRhWWjSouG1VgNqrIbFSh2ahis1EFZ6OKzkYVno0qPhtVgDaqCG1UIdqoYrRRBWmjitJGFaaNKk4bVaA2qkhtVKHaqGK1UQVro4rWRhWujSpeG1XANurqcerqcaqYbbigbbiobbiwbbi4bfjqcVzkNnz1OC52G756HBe9DRe+DRe/DRfADRfBDV89jovhhq8ex0Vxw1eP4+K44avHcZHc8NXjuFhu+OpxXDQ3XDg3XFwIXGAIXEQ3XEg3XEw3XFA3XFQ3PK9MiuuG55VJkd3wvDIpthsuuBsuuhsuvBsuvhtuK5MivOG2MinGG24rk6K84WVlUpw3vKxMivSGl5VJsd5wwd5w0d5w4d5w8d5wAd9wEd9wId9wMd9wQd9wUd9wYd9wcd9wgd9wkd9wod9wsd9wwd9w0d9w4d9w8d9wAeBwEeBwIeBwMeBwQeBwUeBwYeBwceBwgeBwkeBwoeBwseBwweBw0eBw4eBw8eBwAeFwEeFwIeFwMeFwQeFwUeFwYeFwceFoAsPRRIajCQ1HExuOJjgcTXQ4mvBwtNXjtNXjNBHiaELE0cSIowkSRxMljrZ6nCZOHG31OE2kONrqcZpYcTTB4miixdGEi6OJF0dbPU4TMY62epwmZhxt9ThN1Dja6nGauHG01eM0keNoq8dpYsfRBI+jLb6kLb6kiR9HE0COJoIcTQg5mhhytMWXNFHkaIsvaeLI0RZf0kSSowklRxNLjiaYHE00OdriS5p4crTFlzQR5WiLL2liytEWX9JElaMtvqSJK0dbfEkTWY4mtBxNbDma4HI00eVowsvRxJejCTBHE2GOJsQcTYw5miBzNFHmaMLM0cSZowk0RxNpjibUHE2sOZpgczTR5mjCzdHEm6MJOEcTcY4m5BxNzDmaoHM0Uedows7RxJ2jCTxHE3mOJvQcTew5uuBzdNHn6MLP0cWfowtARxeBji4EHV0MOrogdHRR6OjC0NHFoaMLREcXiY4uFB1dLDq6YHT01eP01eN08ejoAtLRRaSjC0lHF5OOvnqcLiodffU4XVw6+upxush0dKHp6GLT0QWno4tOR189Thefjr56nC5CHX31OF2MOvrqcboodfTV43Rx6uirx+ki1dGFqqMvvqQvvqSLVkcXro4uXh1dwDq6iHX0xZd0Mevoiy/potbRF1/Sxa2jC1xHF7mOLnQdXew6+uJLuuh19MWXdPHr6Isv6SLY0Rdf0sWwoy++pItiR198SRfHji6QHV0kO7pQdnSx7OiC2dFFs6MLZ0cXz44uoB1dRDu6kHZ0Me3ogtrRRbWjC2tHF9eOLrAdXWQ7utB2dLHt6ILb0UW3owtvRxffziTAnUmEO5MQdyYx7kyC3JlEuTMJc2cS584k0J1JpDuTUHcmse5Mgt2ZRLszCXdnEu/OJOCdScQ7k5B3JjHvTILemUS9Mwl7ZxL3ziTwnUnkO5PQdyb1OEzqcZhEvzMJf2cS/84kAJ5JBDyTehwmMfBM6nGYRMEzqcdhEgfPJBCeSSQ8k1B4JrHwTOpxmETDM6nHYRIPz6Qeh0lEPJN6HCYx8UzqcZhExTOpx2ESF88kMJ6prEyWlUmx8UyC45lExzMJj2cSH89UVyZFyDPVlUkx8kx1ZVKUPJMweSZx8kwC5ZlEyjP5yqRYeSZfmRQtz+Qrk+LlmdrKpIh5prYyKWaeqa1MippnEjbPJG6eSeA8k8h5JqHzTGLnmQTPM4meZxI+zyR+nkkAPZMIeiYh9Exi6Akx9IQYekIMPSGGnhBDT4ihJ8TQE2LoCTH0hBh6Qgw9IYaeEENPiKEnxNATYugJMfSEGHpCDD0hhp4QQ0+IoSfE0BNi6Akx9IQYekIMPSGGnhBDT4ihJ8TQE2LoCTH0hBh6Qgw9IYaeEENPqMch1OMQYugJMfSEGHpCDD0hhp5Qj0OIoSfU4xBi6An1OIQYekIMPSGGnhBDT4ihJ9TjEGLoCfU4hBh6Qj0OIYaeUI9DiKEn1OMQYugJ9TiEGHpCDD1RVybryqQYekIMPSGGnhBDT4ihJ3xlUgw94SuTYugJX5kUQ0+IoSfE0BNi6Akx9ERbmRRDT7SVSTH0RFuZFENP9JVJMfREX5kUQ0/0lUkx9IQYekIMPSGGnhBDT4qhJ8XQk2LoSTH0pBh6Ugw9KYaeFENPiqEnxdCTYuhJMfSkGHpSDD0php4UQ0+KoSfF0JNi6Ekx9KQYelIMPSmGnhRDT4qhJ8XQk2LoSTH0pBh6Ugw9KYaeFENPiqEnxdCTYuhJMfSkGHpSDD0php4UQ0+KoSfF0JNi6Ekx9KQYelIMPSmGnlSPQ6rHIcXQk2LoSTH0pBh6Ugw9qR6HFENPqschxdCT6nFIMfSkGHpSDD0php4UQ0+qxyHF0JPqcUgx9KR6HFIMPakehxRDT6rHIcXQk+pxSDH0pBh60lcmfWVSDD0php4UQ0+KoSfF0JNtZVIMPdlWJsXQk21lUgw9KYaeFENPiqEnxdCTfWVSDD3ZVybF0JN9ZVIMPbP4EmYx9MziS5jF0DOLL2EWQ88shp5ZDD2zGHpmMfTMYuiZxdAzi6FnFkPPLIaeWQw9sxh6ZjH0zGLomcXQM4uhZxZDzyyGnlkMPbMYemYx9Mxi6JnF0DOLoWcWQ88shp5ZDD2zGHpmMfTMYuiZxdAzi6FnFkPPLIaeWQw9sxh6ZjH0zGLomcXQM4uhZxZDzyyGnlkMPbMYemYx9Mxi6JnF0DOLoWcWQ88shp5ZDD2zGHrm1ePk1eNkMfTMYuiZxdAzi6FnFkPPvHqcLIaeefU4WQw98+pxshh6ZjH0zGLomcXQM4uhZ149ThZDz7x6nCyGnnn1OFkMPfPqcbIYeubV42Qx9Myrx8li6JnF0DO3lcm2MimGnlkMPbMYemYx9Mxi6Jn7yqQYeua+MimGnrmvTIqhp4mhp4mhp4mhp4mhp4kvoYmhp4kvoYmhp4kvoYmhp4kvoYmhp4kvoYmhp4kvoYmhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mhp4mh58m9nm+Nyb2ezw+f3Ctn3Mm9cu54cq+XHHvjfNnkXudP3Pz3D7/+9MMfv/74ty/f/2P8Psrff/5T/BjK8Z+//c9f41/++OtPX7/+9Jc//PXXX/7045///uuP44dTxr99SeOP8b77j+ONyT5+WAXrr/y7zP/85/i9lf8F","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"use std::hash::pedersen_hash;\n\nglobal TREE_DEPTH: u32 = 20;\nglobal MAX_PAYOUTABLE_AMOUNT: u64 = 9_223_372_036_854_775_807; // floor(u64::MAX / 2)\n\nfn hash_pair(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right])\n}\n\nfn commitment_hash(\n    user_secret: Field, market_id: Field, position_side: u1, amount: u64, blinding_factor: Field,\n) -> Field {\n    // Matches Cairo `merkle_tree_lib::commitment_hash`.\n    let ab = hash_pair(user_secret, market_id);\n    let cd = hash_pair(position_side as Field, amount as Field);\n    let e0 = hash_pair(blinding_factor, 0);\n    hash_pair(hash_pair(ab, cd), e0)\n}\n\n// Public input schema (order is strict and bound in Market.cairo):\n// 0: market_id\n// 1: market_root\n// 2: market_outcome\n// 3: nullifier\n// 4: payout_low\n// 5: payout_high\n// 6: payout_recipient\nfn main(\n    user_secret: Field,\n    position_side: u1,\n    amount: u64,\n    blinding_factor: Field,\n    leaf_index: u32,\n    merkle_siblings: [Field; TREE_DEPTH],\n    market_id: pub Field,\n    market_root: pub Field,\n    market_outcome: pub u1,\n    nullifier: pub Field,\n    payout_low: pub Field,\n    payout_high: pub Field,\n    _payout_recipient: pub Field,\n) {\n    assert(amount > 0);\n    assert(amount <= MAX_PAYOUTABLE_AMOUNT);\n\n    let commitment = commitment_hash(\n        user_secret,\n        market_id,\n        position_side,\n        amount,\n        blinding_factor,\n    );\n\n    // Membership proof against current market root.\n    let mut node = commitment;\n    for level in 0..TREE_DEPTH {\n        let bit: u1 = ((leaf_index >> level) & 1) as u1;\n        let sibling = merkle_siblings[level];\n\n        if bit == 0 {\n            node = hash_pair(node, sibling);\n        } else {\n            node = hash_pair(sibling, node);\n        }\n    }\n    assert(node == market_root);\n\n    // Must be on winning side.\n    assert(position_side == market_outcome);\n\n    // Nullifier derivation.\n    let computed_nullifier = hash_pair(user_secret, market_id);\n    assert(computed_nullifier == nullifier);\n\n    // Exact payout rule (current MVP): 2x stake, u256 low/high encoding.\n    let expected_payout_low = (amount * 2) as Field;\n    assert(payout_low == expected_payout_low);\n    assert(payout_high == 0);\n}\n","path":"/Users/sam/Desktop/Starknet/ShadowMarket/circuits/claim_reward/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}